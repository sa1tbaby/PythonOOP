ООП Python

1. Парадигма ООП
1) Инкапсуляция - Подразумевает собой, особенность классов, как неких *Абстрактных объектов(1) , хранить в себе атрибуты и методы, предоставляя тем самым API для работы
2) Полиморфизм - подразумевает возможность использовать один и тот же интерфейс для различных классов явно разграничивая принадлежность интерфейса к конкретному классу 
	* Методы поля и атрибуты классов начинающиеся на __ # __someAttr, 	считаются приватными, однако вызвать их также можно, тем не менее 	благодаря ним, можно осуществить некий полиморфизм при *Наследовании 	ведь при такой записи параметр класса будет перезаписан интерпретатором не 	как "__someAttr", а как "_SomeClass__someAttr"
		
3) Наследование
4) Абстракция







(1) - Объе́кт в программировании — некоторая сущность в цифровом пространстве, обладающая определённым состоянием и поведением, имеющая определённые свойства (атрибуты) и операции над ними (методы).

2. Дандер методы

2.1 Конструирование и инициализация.

	Всем известен самый базовый магический метод, __init__. С его помощью мы можем инициализировать объект. Однако, когда я пишу 
	x = SomeClass(), 
		__init__ не самое первое, что вызывается. 
	На самом деле, экземпляр объекта создаёт метод __new__, а затем аргументы передаются в инициализатор. 
	На другом конце жизненного цикла объекта находится метод __del__. Давайте подробнее рассмотрим эти три магических метода:

2.1.1 Метод __new__
 	__new__(cls, [...) 	Это первый метод, который будет вызван при инициализации объекта.
	 Он принимает в качестве параметров класс и потом любые другие аргументы, которые будут переданы в 	__init__.
	 __new__ 	используется весьма редко, но иногда бывает полезен, в частности, когда класс наследуется от неизменяемого (immutable) типа, такого как кортеж (tuple) или строка. 

2.1.2 Метод __init__
	__init__(self, [...)	Инициализатор класса. 
	Ему передаётся всё, с чем был вызван первоначальный конструктор (так, например, если мы вызываем 
	x = SomeClass(10, 'foo'),	
	 __init__	получит 10 и 'foo' в качестве аргументов.
	 __init__	 почти повсеместно используется при определении классов.

2.1.2 Метод __del__
	__del__(self)	Если __new__ и __init__ образуют конструктор объекта, __del__ это его деструктор. 
	Он не определяет поведение для выражения del x (поэтому этот код не эквивалентен	 x.__del__()).
	 Скорее, он определяет поведение объекта в то время, когда объект попадает в сборщик мусора. Это может быть довольно удобно для объектов, которые могут требовать дополнительных чисток во время удаления, таких как сокеты или файловыве объекты.
from os.path import join

2.1.N Example

class FileObject:
    '''Обёртка для файлового объекта, чтобы быть уверенным в том, что файл будет закрыт при удалении.'''

    def __init__(self, filepath='~', filename='sample.txt'):
        # открыть файл filename в filepath в режиме чтения и записи
        self.file = open(join(filepath, filename), 'r+')

    def __del__(self):
        self.file.close()
        del self.file

2.2 Магические методы сравнения
2.1.1 __cmp__
	__cmp__(self, other) 	Самый базовый из методов сравнения. 
Он, в действительности, определяет поведение для всех операторов сравнения (>, ==, !=, итд.), но не всегда так, как вам это нужно, например:
	(если эквивалентность двух экземпляров определяется по 	одному критерию, а то что один больше другого по какому-нибудь 	другому). 

	__cmp__ должен вернуть отрицательное число, если:
	 	self < other, 
	Ноль:
	 	если self == other, 
	положительное число:
	 	в случае self > other. 
	Но, обычно, лучше определить каждое сравнение, которое вам нужно, чем определять их всех в __cmp__.
	 Но __cmp__ может быть хорошим способом избежать повторений и увеличить ясность, когда все необходимые сравнения оперерируют одним критерием.

__eq__
__eq__(self, other)
Определяет поведение оператора равенства, ==.

__ne__
__ne__(self, other)
Определяет поведение оператора неравенства, !=.

__lt__
__lt__(self, other)
Определяет поведение оператора меньше, <.


__gt__
__gt__(self, other)
Определяет поведение оператора больше, >.

__le__
__le__(self, other)
Определяет поведение оператора меньше или равно, <=.


__ge__
__ge__(self, other)
Определяет поведение оператора больше или равно, >=.

2.1.N Example
	Для примера расммотрим класс, описывающий слово. 
	Мы можем сравнивать слова лексиграфически (по алфавиту), что является дефолтным поведением при сравнении строк, но можем захотеть использовать при сравнении какой-нибудь другой критерий, такой, как длина или количество слогов. 
	В этом примере мы будем сравнивать по длине. Вот реализация:

class Word(str):
    '''Класс для слов, определяющий сравнение по длине слов.'''

    def __new__(cls, word):
        # Мы должны использовать __new__, так как тип str неизменяемый
        # и мы должны инициализировать его раньше (при создании)
        if ' ' in word:
            print "Value contains spaces. Truncating to first space."
            word = word[:word.index(' ')] # Теперь Word это все символы до первого пробела
        return str.__new__(cls, word)

    def __gt__(self, other):
        return len(self) > len(other)
    def __lt__(self, other):
        return len(self) < len(other)
    def __ge__(self, other):
        return len(self) >= len(other)
    def __le__(self, other):
        return len(self) <= len(other)

	Теперь мы можем создать два Word (при помощи Word('foo') и Word('bar')) и сравнить их по длине. 
	Заметьте, что мы не определяли __eq__ и __ne__, так как это приведёт к странному поведению (например, Word('foo') == Word('bar') будет расцениваться как истина). 
	В этом нет смысла при тестировании на эквивалентность, основанную на длине, поэтому мы оставляем стандартную проверку на эквивалентность от str.
	Не обязатльно определять каждый из магических методов сравнения, чтобы полностью охватить все сравнения.
	 Стандартная библиотека предоставляет класс-декторатор в модуле functools, который определит все сравнивающие методы, достаточно определить только __eq__ и ещё один (__gt__, __lt__ и т.п.) 
	Для того, чтобы задействовать её, поместите @total_ordering над определением класса.



3. Паттерны

	1. Одиночка (Singleton)
	Одиночка (Singleton) — это паттерн проектирования, который обеспечивает создание одного и только одного экземпляра класса, и предоставляет глобальную точку доступа к этому экземпляру.
	Классический пример использования паттерна Одиночка - это логгеры. Каждый раз, когда приложение пишет лог, необходимо получать доступ к единственному экземпляру логгера.

Преимущества использования Одиночки:
Гарантирует наличие единственного экземпляра класса
Предоставляет глобальную точку доступа к этому экземпляру
Позволяет создавать необходимое количество экземпляров, контролируя их количество и способ создания

Недостатки использования Одиночки:
Затрудняет написание юнит-тестов
Может привести к созданию глобальных переменных, что в свою очередь приводит к ухудшению модульности и увеличению связности между компонентами приложения.


class Singleton:

    def __new__(
            cls,
            *args,
            **kwargs
    ):
        if not hasattr(cls, '__instance'):
            cls.__instance = super().__new__(cls)
        return cls.__instance



